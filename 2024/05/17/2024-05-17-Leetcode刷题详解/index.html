<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="2024-05-17-Leetcode 刷题详解"><meta name="keywords" content="leetcode,刷题,java,go"><meta name="author" content="Suki Lee,undefined"><meta name="copyright" content="Suki Lee"><title>2024-05-17-Leetcode 刷题详解【Suki Lee】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- script(src=url_for("/js/mathjax/mathjax.js"))--><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {},
  twikoo: {},
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="table">overview</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">table</div><div class="sidebar-toc-progress"><span class="progress-notice">You have read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84nums%E5%92%8C%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6k%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E6%B1%82%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">239. 给定一个数组nums和一个长度k的滑动窗口，求窗口滑动过程中的所有最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">560. 和为k的子数组个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">15. 三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.4.</span> <span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">3.无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.6.</span> <span class="toc-text">438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.7.</span> <span class="toc-text">76. 最小覆盖子串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">88.合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">27.移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%EF%BC%8C80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%EF%BC%8826%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%EF%BC%8C80%EF%BC%8C%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">26，80 删除有序数组中的重复项 （26，只能出现一次，80，只出现两次）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.</span> <span class="toc-text">169. 多数元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arrays"><span class="toc-number">3.</span> <span class="toc-text">Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">189. 轮转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">3.3.</span> <span class="toc-text">238. 除自身以外数组的乘积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">4.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-number">4.1.</span> <span class="toc-text">73. 矩阵置零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">4.2.</span> <span class="toc-text">54 螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">4.3.</span> <span class="toc-text">48. 旋转图像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">5.2.</span> <span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-number">5.5.</span> <span class="toc-text">142. 环形链表II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.6.</span> <span class="toc-text">21. 合并有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.7.</span> <span class="toc-text">23. 合并k个升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">5.8.</span> <span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">5.9.</span> <span class="toc-text">19.删除倒数第n个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">5.10.</span> <span class="toc-text">24.两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">5.11.</span> <span class="toc-text">25.k个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">5.12.</span> <span class="toc-text">138 随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">5.13.</span> <span class="toc-text">148. 排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98"><span class="toc-number">5.14.</span> <span class="toc-text">146 LRU缓存</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/cat.jpg"></div><div class="author-info-name">Suki Lee</div><div class="author-info-description">I am waiting for you</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/urnotsukilee" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="urnotsukilee@gmail.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/public/archives"><span class="pull-top">posts</span><span class="pull-bottom">2</span></a><a class="author-info-articles-tags article-meta" href="/public/tags"><span class="pull-top">tags</span><span class="pull-bottom">7</span></a><a class="author-info-articles-categories article-meta" href="/public/categories"><span class="pull-top">categories</span><span class="pull-bottom">2</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">Home</a><a class="menu-item" href="/tags">Tags</a><a class="menu-item" href="/categories">Categories</a><a class="menu-item" href="/public/archives">Archives</a><a class="menu-item" href="/about">About</a></nav><div class="right-info"><a class="title-name" href="/">Suki Lee</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">2024-05-17-Leetcode 刷题详解</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> Posted At 2024-05-17 | Modified At 2024-05-17</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/public/categories/leetcode/">leetcode</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/public/tags/leetcode/">leetcode</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/public/tags/%E5%88%B7%E9%A2%98/">刷题</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/public/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/public/tags/go/">go</a></div></div></div><div class="main-content"><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="239-给定一个数组nums和一个长度k的滑动窗口，求窗口滑动过程中的所有最大值"><a href="#239-给定一个数组nums和一个长度k的滑动窗口，求窗口滑动过程中的所有最大值" class="headerlink" title="239. 给定一个数组nums和一个长度k的滑动窗口，求窗口滑动过程中的所有最大值"></a>239. 给定一个数组nums和一个长度k的滑动窗口，求窗口滑动过程中的所有最大值</h2><p>题解，假设滑窗内的两个坐标i，j，(i &lt; j), 如果j指向的数大于i，当移动到下个窗口时，如果i没有离开窗口，则必有nums[j]&gt;nums[i]，既i坐标所指的数对最大值无影响，可以永久移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; indexQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!indexQueue.isEmpty()&amp;&amp;nums[i]&gt;=nums[indexQueue.peekLast()])&#123;</span><br><span class="line">                indexQueue.pollLast();</span><br><span class="line">            &#125;  <span class="comment">//当目前将入队的值大于队伍里前面的值，则将前面的值踢出，因为前面的值不可能成为最大值</span></span><br><span class="line">            indexQueue.offerLast(i);<span class="comment">//将新值的坐标压入队列</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = nums[indexQueue.peekFirst()];<span class="comment">//每个窗口最大值的坐标都是队列中第一个坐标，如果第一个坐标不是最大值，则在前面就被踢出队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!indexQueue.isEmpty()&amp;&amp;nums[i]&gt;=nums[indexQueue.peekLast()])&#123;</span><br><span class="line">                indexQueue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            indexQueue.offerLast(i);</span><br><span class="line">            <span class="keyword">while</span>(indexQueue.peekFirst()&lt;=i-k)&#123;</span><br><span class="line">                indexQueue.pollLast();</span><br><span class="line">            &#125;<span class="comment">//当队伍第一个坐标在滑窗之外，则踢出队伍</span></span><br><span class="line">            res[i-k+<span class="number">1</span>] = nums[indexQueue.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这套循环里，队伍保存的是坐标值，坐标对应的值保持单调递减，既最大值一定是第一个坐标对应的值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="560-和为k的子数组个数"><a href="#560-和为k的子数组个数" class="headerlink" title="560. 和为k的子数组个数"></a>560. 和为k的子数组个数</h2><p>算法思路：前缀和</p>
<p>题解：Sn-Sj &#x3D; aj+…an</p>
<p>因此计算aj到an的和，只需要前n项和减去前j项和</p>
<p>在此题中，我们用一个哈希表记录前n项和以及此值的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>, presum = <span class="number">0</span>;</span><br><span class="line">       map.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//记录空值和</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">           presum+=x;<span class="comment">//计算前i项和</span></span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(presum-k))&#123;<span class="comment">//如果哈希表中存在presum-k的值，既说明存在前i项和-前j项和=k</span></span><br><span class="line">               count+=map.get(presum-k);</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(presum,map.getOrDefault(presum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">       map[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>, presum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;x:nums)&#123;</span><br><span class="line">           presum+=x;</span><br><span class="line">           <span class="keyword">if</span>(map.<span class="built_in">find</span>(presum-k)!=map.<span class="built_in">end</span>())&#123; <span class="comment">//=map.end() means didn&#x27;t exits key presum-k</span></span><br><span class="line">               count+=map[presum-k];</span><br><span class="line">           &#125;</span><br><span class="line">           map[presum]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给定一个无需数组，返回所有和为0且互不重复的三元数组，如[-2,0,1,1,2]，返回[[-2,0,2],[-2,1,1]]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用三指针+排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="literal">null</span> || nums.length&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;nums.length;first++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first+<span class="number">1</span>;</span><br><span class="line">           <span class="type">int</span> third=nums.length-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(second&lt;third)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[first]+nums[second]+nums[third]==<span class="number">0</span>)&#123;</span><br><span class="line">                   res.add(Arrays.asList(nums[first],nums[second],nums[third]));</span><br><span class="line">                   second++;</span><br><span class="line">                   third--;</span><br><span class="line">                   <span class="comment">//second和third指针变化后，如果值一样，则跳过，以避免重复</span></span><br><span class="line">                   <span class="keyword">while</span>(second&lt;third&amp;&amp;nums[second]==nums[second-<span class="number">1</span>]) second++;</span><br><span class="line">                   <span class="keyword">while</span>(second&lt;third&amp;&amp;nums[third]==nums[third+<span class="number">1</span>]) third--;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(nums[first]+nums[second]+nums[third]&gt;<span class="number">0</span>) third--;</span><br><span class="line">               <span class="keyword">else</span> second++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p> 左右指针从两边往中间移动，维护一个左边最大值和一个右边最大值</p>
<p> 当height[left]&lt;height[right]时，必有右边最大值大于左值，既右边有一堵墙可顶住，此时就计算左边可积水量，反之一样</p>
<p> 上述结果能成立，是因为两个指针移动的规则就是基于当前两边值大小进行的，右值如果比左边大，则右边指针不会动，直到出现左值比它大为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           leftMax=Math.max(leftMax,height[left]);</span><br><span class="line">           rightMax=Math.max(rightMax,height[right]);</span><br><span class="line">           <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">               res+=leftMax-height[left];</span><br><span class="line">               left++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res+=rightMax-height[right];</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">       <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">               <span class="comment">//重复字符有两种情况：</span></span><br><span class="line">               <span class="comment">// 1. abca, 到遍历到第二个a时，此时更新left到b即可，既s.charAt(a)+1</span></span><br><span class="line">               <span class="comment">// 2. abba, 当遍历到第二个b时，left更新到第二个b处，此时第一个a还在map中，因此left依然在第二个b处，而非a处，既left&gt;s.charAt(a)+1</span></span><br><span class="line">               left = Math.max(left,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">           map.put(s.charAt(i),i); <span class="comment">//无论什么情况，都更新s.charAt(i)的位置</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p> s &#x3D; “cbaebabacd”, p &#x3D; “abc”，答案为[0,6] 第0个位置的’cba’和第6个位置的’bac’</p>
<p> 解法：维护一个和p长度相等的窗口，在s上滑动，两个窗口内的字符串含有的字母相同时则记录窗口第一个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(),pLen=p.length();</span><br><span class="line">       <span class="keyword">if</span>(sLen&lt;pLen)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();&#125;</span><br><span class="line">       <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pLen;i++)&#123;</span><br><span class="line">           ++sCount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">           ++pCount[p.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span>(Arrays.equals(sCount,pCount)) res.add(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sLen-pLen;++i)&#123;</span><br><span class="line">           --sCount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">           ++sCount[s.charAt(i+pLen)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">           <span class="keyword">if</span>(Arrays.equals(sCount,pCount))  res.add(i+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><p>返回s中含有t所有字符的最小子串</p>
<pre><code>思路：滑动窗口，不断向右扩大窗口直到窗口里含有t的所有字符，然后窗口左边收缩直到缺少一个t的字符
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//记录t的所有字符</span></span><br><span class="line">     Map&lt;Character,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//记录当前窗口的字符，只关心t含有的字符</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tlen</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tlen;i++)&#123;</span><br><span class="line">            tMap.put(t.charAt(i),tMap.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> Integer.MAX_VALUE, ansL=-<span class="number">1</span>,ansR=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span>(r&lt;slen)&#123;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;slen &amp;&amp; tMap.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                cnt.put(s.charAt(r),cnt.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每扩大一个r就检查一次</span></span><br><span class="line">            <span class="keyword">while</span>(check()&amp;&amp;l&lt;=r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;maxLen)&#123;</span><br><span class="line">                    maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                    ansR = maxLen+l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tMap.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    cnt.put(s.charAt(l),cnt.getOrDefault(s.charAt(l),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansL == -<span class="number">1</span>? <span class="string">&quot;&quot;</span>:s.substring(ansL,ansR);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> tMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> (Character) entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(cnt.getOrDefault(key,<span class="number">0</span>)&lt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用count计算滑窗里符合t的元素的个数，减少hashmap的对比计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] tMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            tMap[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>, min=s.length()+<span class="number">1</span>,slen=s.length();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;slen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tMap[s.charAt(r)]==<span class="number">0</span>)&#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt[s.charAt(r)]&lt;tMap[s.charAt(r)])&#123;<span class="comment">//当滑窗里的字符数量不够时才增加</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[s.charAt(r)]++;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(count==t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-l&lt;min)&#123;</span><br><span class="line">                    min=r-l;</span><br><span class="line">                    index=l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tMap[s.charAt(l)]==<span class="number">0</span>)&#123;<span class="comment">//t中没有该元素，跳过</span></span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tMap[s.charAt(l)]==cnt[s.charAt(l)])&#123;<span class="comment">//即将去掉的字符，目前滑窗里的数量等于t的数量，去掉时则不符合要求，count减掉；</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[s.charAt(l)]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min==s.length()+<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(index,index+min);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h2><p>思路：双指针从尾部遍历两个数组，把较大的数先放入尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">pm</span> <span class="operator">=</span> m-<span class="number">1</span>,pn = n-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> cur;</span><br><span class="line">       <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(pm&gt;=<span class="number">0</span>||pn&gt;=<span class="number">0</span>)&#123; <span class="comment">// handle while one list has no entry</span></span><br><span class="line">           <span class="keyword">if</span>(pm==-<span class="number">1</span>)&#123;</span><br><span class="line">               cur = nums2[pn--];</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pn==-<span class="number">1</span>)&#123;</span><br><span class="line">               cur = nums1[pm--];</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[pm]&lt;nums2[pn])&#123;</span><br><span class="line">               cur = nums2[pn--];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = nums1[pm--];</span><br><span class="line">           &#125;</span><br><span class="line">           nums1[tail--] = cur;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p>思路：双指针，一个快指针遍历数组，一个慢指针指向目前被添加元素的数组，当快指针指向的数字不等于val时，将快指针指向的数字插入慢指针指向的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span> ,low = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(fast&lt;nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[fast]!=val) nums[low++] = nums[fast++];</span><br><span class="line">           <span class="keyword">else</span> fast++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> low;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26，80-删除有序数组中的重复项-（26，只能出现一次，80，只出现两次）"><a href="#26，80-删除有序数组中的重复项-（26，只能出现一次，80，只出现两次）" class="headerlink" title="26，80 删除有序数组中的重复项 （26，只能出现一次，80，只出现两次）"></a>26，80 删除有序数组中的重复项 （26，只能出现一次，80，只出现两次）</h2><p>思路类似上面的双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>, low = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">while</span>(fast&lt;nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[fast]!=nums[low-<span class="number">2</span>])&#123;</span><br><span class="line">               nums[low++] = nums[fast];</span><br><span class="line">           &#125;</span><br><span class="line">           fast++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> low;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p>找到数组里超过n&#x2F;2的元素</p>
<p>方法五：Boyer-Moore 投票算法<br>前面的人来插旗，后面不一样的人来就拔旗消除，多数的那一边一定是能最后插旗的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]</p>
<p>思路：先根据每个区间的左节点进行sorting，然后创建一个新的array，如有重叠，则修改最后一个区间的右节点，如没有重叠，则直接添加入array中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1,<span class="type">int</span>[] interval2)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>]-interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; mergeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> L=intervals[i][<span class="number">0</span>],R=intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(mergeList.size()==<span class="number">0</span>||mergeList.get(mergeList.size()-<span class="number">1</span>)[<span class="number">1</span>]&lt;L)&#123;</span><br><span class="line">                mergeList.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,R&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mergeList.get(mergeList.size()-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(mergeList.get(mergeList.size()-<span class="number">1</span>)[<span class="number">1</span>],R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> mergeList.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[mergeList.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h2><pre><code>输入数组，轮转k次
</code></pre>
<p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]</p>
<p>思路1：将整个数组反转，将前k部分反转，再将后面部分反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2<br>使用新arr，将原数组第i个位置的元素放到新数组 (i+k)mod n的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newArr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            newArr[(i+k)%n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">assign</span>(newArr.<span class="built_in">begin</span>(),newArr.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h2><p>思路：对于第i个位置的乘积，获得其左边数组的乘积和右边数组的乘积</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        R[nums.length-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            L[i] = nums[i-<span class="number">1</span>]*L[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            R[i] = nums[i+<span class="number">1</span>]*R[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            answer[i] = L[i]*R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> leftMul=<span class="number">1</span>,rightMul=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(ans,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i]*=leftMul;</span><br><span class="line">            ans[nums.length-i-<span class="number">1</span>]*=rightMul;</span><br><span class="line">            leftMul*=nums[i];</span><br><span class="line">            rightMul*=nums[nums.length-i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p>
<p>用额外空间记录哪一行或列需要被标记</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    row := <span class="built_in">make</span>([]<span class="type">bool</span>,<span class="built_in">len</span>(matrix))</span><br><span class="line">    column := <span class="built_in">make</span>([]<span class="type">bool</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">for</span> i,r := <span class="keyword">range</span> matrix &#123; <span class="comment">//range array= index,value</span></span><br><span class="line">        <span class="keyword">for</span> j,v := <span class="keyword">range</span> r&#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>&#123;</span><br><span class="line">                row[i] = <span class="literal">true</span></span><br><span class="line">                column[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,r:= <span class="keyword">range</span> matrix&#123;</span><br><span class="line">        <span class="keyword">for</span> j :=<span class="keyword">range</span> r&#123;</span><br><span class="line">            <span class="keyword">if</span> row[i] || column[j]&#123;</span><br><span class="line">                r[j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">// Boolean 类初始为null,boolean初始为false</span></span><br><span class="line">        <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[matrix.length];</span><br><span class="line">        <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    row[i]=<span class="literal">true</span>;</span><br><span class="line">                    col[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i]||col[j])&#123;</span><br><span class="line">                    matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h2><p>螺旋输出矩阵到一个array</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) ==<span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        rows,columns = <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        order = <span class="built_in">make</span>([]<span class="type">int</span>,rows*columns)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        left,right,top,bottom = <span class="number">0</span>,columns<span class="number">-1</span>,<span class="number">0</span>,rows<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right &amp;&amp; top&lt;=bottom&#123;</span><br><span class="line">        <span class="comment">//从左到右</span></span><br><span class="line">        <span class="keyword">for</span> column :=left; column &lt;= right; column++&#123;</span><br><span class="line">            order[index] = matrix[top][column]</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> row := top+<span class="number">1</span>; row&lt;=bottom;row++&#123;</span><br><span class="line">            order[index] = matrix[row][right]</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left&lt;right &amp;&amp; top&lt;bottom&#123;</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">for</span> column:=right<span class="number">-1</span>;column&gt;left;column--&#123;</span><br><span class="line">                order[index] = matrix[bottom][column]</span><br><span class="line">                index++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">for</span> row:=bottom;row&gt;top;row--&#123;</span><br><span class="line">                order[index] = matrix[row][left]</span><br><span class="line">                index++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">        top++</span><br><span class="line">        bottom--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>将矩阵顺时针旋转90度</p>
<p>思路1：上下翻转后对角线翻转</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    n:=<span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="comment">//水平上下翻转</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++&#123;</span><br><span class="line">        matrix[i],matrix[n<span class="number">-1</span>-i] = matrix[n<span class="number">-1</span>-i],matrix[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;i;j++&#123;</span><br><span class="line">            matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>找到两个链表相交的起点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> headA==<span class="literal">nil</span> || headB== <span class="literal">nil</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    pa := headA;</span><br><span class="line">    pb := headB;</span><br><span class="line">    <span class="keyword">for</span> pa!=pb &#123;</span><br><span class="line">        <span class="keyword">if</span> pa==<span class="literal">nil</span> &#123;</span><br><span class="line">            pa=headB</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pa = pa.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pb==<span class="literal">nil</span>&#123;</span><br><span class="line">            pb=headA</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pb=pb.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>思路：记录当前位置的前一个node和后一个node，将当前指针的next指向前一个node，并移动当前指针到下一个node</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不断将后面部分提到前面</span></span><br><span class="line"><span class="comment">//prev-&gt;1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//1-&gt;prev-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//2-&gt;1-&gt;prev-&gt;3</span></span><br><span class="line"><span class="comment">//3-&gt;2-&gt;1-&gt;prev </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//对于初始node，前一个node为nil，go初始化struct为nil</span></span><br><span class="line">    <span class="keyword">var</span> prev *ListNode </span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur!=<span class="literal">nil</span> &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = prev</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prev-&gt;1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">//prev-&gt;2-&gt;1-&gt;3 将3和prev指向部分翻转</span></span><br><span class="line"><span class="comment">//prev-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head==<span class="literal">nil</span> || head.Next==<span class="literal">nil</span>&#123;<span class="keyword">return</span> head&#125;</span><br><span class="line">    prev:=&amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line">    <span class="keyword">for</span> head.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        next:=head.Next</span><br><span class="line">        head.Next=next.Next</span><br><span class="line">        next.Next=prev.Next</span><br><span class="line">        prev.Next=next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>判断一个链表是否为回文（从头到尾和从尾到头一样）</p>
<p>思路1：</p>
<ol>
<li>快慢指针，快走两个，慢走一个，快到终点，慢到中点</li>
<li>翻转后半链表</li>
<li>对比前后链表</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    first_half_end := findMiddle(head)</span><br><span class="line">    secode_half_head :=reverseList(first_half_end.Next)</span><br><span class="line"></span><br><span class="line">    first_half_head := head</span><br><span class="line">    <span class="keyword">for</span> secode_half_head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> first_half_head.Val!=secode_half_head.Val&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        first_half_head = first_half_head.Next</span><br><span class="line">        secode_half_head = secode_half_head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMiddle</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    fast :=head</span><br><span class="line">    slow :=head</span><br><span class="line">    <span class="keyword">for</span> fast.Next!=<span class="literal">nil</span> &amp;&amp; fast.Next.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur!=<span class="literal">nil</span>&#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = prev</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>判断链表是否存在环</p>
<p>思路：设计快慢指针，两指针如果能相遇则存在，快指针走到nil则不存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow := head</span><br><span class="line">    fast := head.Next</span><br><span class="line">    <span class="keyword">for</span> slow!=fast&#123;</span><br><span class="line">        <span class="keyword">if</span> fast==<span class="literal">nil</span>||fast.Next==<span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h2><p>找到链表是否存在环，如存在，返回入口节点</p>
<p>思路：快指针是慢指针的两倍,f&#x3D;2s</p>
<p>相遇时快指针比慢指针多走n个环，f&#x3D;s+nb</p>
<p>可得s&#x3D;nb，f&#x3D;2nb</p>
<p>设从头走a步到达入口，那么所有走到链表入口的步数就是k&#x3D;a+nb</p>
<p>当快慢指针相遇时，慢指针走了nb步，再走a步就到入口，此时设另一个指针从头开始走，当他们相遇时，新指针也走了a步到达入口，既两个指针相遇在入口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow := head</span><br><span class="line">    fast := head</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast==<span class="literal">nil</span> || fast.Next ==<span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow==fast &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head</span><br><span class="line">    <span class="keyword">for</span> slow!=fast&#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并有序链表"><a href="#21-合并有序链表" class="headerlink" title="21. 合并有序链表"></a>21. 合并有序链表</h2><p>将两个链表按照升序合并</p>
<p>思路：递归</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> list1==<span class="literal">nil</span> &#123;<span class="keyword">return</span> list2&#125; <span class="comment">//list1走完，则只要l2</span></span><br><span class="line">    <span class="keyword">if</span> list2==<span class="literal">nil</span> &#123;<span class="keyword">return</span> list1&#125; <span class="comment">//list2走完，只要l1</span></span><br><span class="line">    <span class="keyword">if</span> list1.Val &lt;= list2.Val &#123;</span><br><span class="line">        <span class="comment">//list1数值小，因此l1当前值被合并，剩余值和l2合并</span></span><br><span class="line">        list1.Next = mergeTwoLists(list1.Next,list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//反之</span></span><br><span class="line">        list2.Next = mergeTwoLists(list1,list2.Next)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="23-合并k个升序链表"><a href="#23-合并k个升序链表" class="headerlink" title="23. 合并k个升序链表"></a>23. 合并k个升序链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> list1==<span class="literal">nil</span> &#123;<span class="keyword">return</span> list2&#125; <span class="comment">//list1走完，则只要l2</span></span><br><span class="line">    <span class="keyword">if</span> list2==<span class="literal">nil</span> &#123;<span class="keyword">return</span> list1&#125; <span class="comment">//list2走完，只要l1</span></span><br><span class="line">    <span class="keyword">if</span> list1.Val &lt;= list2.Val &#123;</span><br><span class="line">        <span class="comment">//list1数值小，因此l1当前值被合并，剩余值和l2合并</span></span><br><span class="line">        list1.Next = mergeTwoLists(list1.Next,list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//反之</span></span><br><span class="line">        list2.Next = mergeTwoLists(list1,list2.Next)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前lists分开两半[list1,list2,list3,list4,list5]=》[list1,list2,list3],[list4,list5]</span></span><br><span class="line"><span class="comment">//再继续分=&gt; [list1,list2]和[list3]，[list4]和[list5]</span></span><br><span class="line"><span class="comment">//只有一个list时返回，两个list时如[list1,list2]，继续分成list1和list2，然后合并成list12，再和list3合并成list123，list45同理，再将list123和list45合并成list12345</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(lists []*ListNode,left <span class="type">int</span>,right <span class="type">int</span>)</span></span> *ListNode&#123;</span><br><span class="line">    <span class="keyword">if</span> left==right&#123;<span class="keyword">return</span> lists[left]&#125;</span><br><span class="line">    <span class="keyword">if</span> left&gt;right &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    mid := (left+right)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(divide(lists,left,mid),divide(lists,mid+<span class="number">1</span>,right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">return</span> divide(lists,<span class="number">0</span>,<span class="built_in">len</span>(lists)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span>(head *ListNode) &#123;</span><br><span class="line">    <span class="keyword">var</span> tail *ListNode</span><br><span class="line">    carry :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l1!=<span class="literal">nil</span>||l2!=<span class="literal">nil</span>&#123;</span><br><span class="line">        n1,n2 := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1!=<span class="literal">nil</span>&#123;</span><br><span class="line">            n1=l1.Val</span><br><span class="line">            l1=l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2!=<span class="literal">nil</span>&#123;</span><br><span class="line">            n2=l2.Val</span><br><span class="line">            l2=l2.Next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum := n1+n2+carry</span><br><span class="line">        sum,carry = sum%<span class="number">10</span>,sum/<span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="comment">//第一个node未进入list时，初始化第一个node并加入head</span></span><br><span class="line">            head=&amp;ListNode&#123;Val:sum&#125;</span><br><span class="line">            <span class="comment">//指针指向head</span></span><br><span class="line">            tail=head</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//第一个node已经初始化，指针不断后移并添加新的sum</span></span><br><span class="line">            tail.Next = &amp;ListNode&#123;Val: sum&#125;</span><br><span class="line">            tail=tail.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry&gt;<span class="number">0</span>&#123;</span><br><span class="line">        <span class="comment">//当循环结束时，carry仍然大于0，则添加一个新的node</span></span><br><span class="line">        tail.Next=&amp;ListNode&#123;Val:carry&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除倒数第n个节点"><a href="#19-删除倒数第n个节点" class="headerlink" title="19.删除倒数第n个节点"></a>19.删除倒数第n个节点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    first := head</span><br><span class="line">    dummy := &amp;ListNode&#123;Val:<span class="number">0</span>,Next:head&#125; <span class="comment">//避免删除头结点时出现问题</span></span><br><span class="line">    second := dummy</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        first=first.Next</span><br><span class="line">    &#125; <span class="comment">//快指针走n步后慢指针跟着走</span></span><br><span class="line">    <span class="comment">//当快指针走到头时，慢指针走了L-n+1步，指向的节点为倒数第n-1个节点</span></span><br><span class="line">    <span class="comment">//将倒数第n-1个节点的下一个节点指向倒数第n+1个节点，既删除第n个节点</span></span><br><span class="line">    <span class="keyword">for</span> first!=<span class="literal">nil</span>&#123;</span><br><span class="line">        first=first.Next</span><br><span class="line">        second=second.Next</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next=second.Next.Next</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2><ol>
<li><p>递归，终点是只剩一个节点或没有</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">*     Val int</span></span><br><span class="line"><span class="comment">*     Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"> <span class="keyword">if</span> head==<span class="literal">nil</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line"> <span class="keyword">if</span> head.Next==<span class="literal">nil</span> &#123;<span class="keyword">return</span> head&#125;</span><br><span class="line"> <span class="comment">//新的头结点=第二个节点，新的头结点下一个节点=头结点</span></span><br><span class="line"> newhead := head.Next</span><br><span class="line"> <span class="comment">//旧头结点的下一个节点=新的头结点之后链表的交换结果的头结点</span></span><br><span class="line"> head.Next = swapPairs(newhead.Next)</span><br><span class="line"> <span class="comment">//再将旧头结点给到新的头结点（此时旧头结点之后的节点都被交换了）</span></span><br><span class="line"> newhead.Next = head</span><br><span class="line"> <span class="keyword">return</span> newhead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">*     Val int</span></span><br><span class="line"><span class="comment">*     Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//创建一个dummy空节点指向头结点</span></span><br><span class="line"><span class="comment">//tmp指向dummy</span></span><br><span class="line"><span class="comment">//node1 = tmp.Next,node2=tmp.Next.Next</span></span><br><span class="line"><span class="comment">//既tmp-&gt;node1-&gt;node2-&gt;剩余节点</span></span><br><span class="line"><span class="comment">//交换node1,node2</span></span><br><span class="line"><span class="comment">//tmp-&gt;node2-&gt;node1-&gt;剩余节点</span></span><br><span class="line"><span class="comment">//将tmp指向node1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"> dummy := &amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line"> tmp := dummy</span><br><span class="line"> <span class="keyword">for</span> tmp.Next!=<span class="literal">nil</span>&amp;&amp;tmp.Next.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">     node1 := tmp.Next</span><br><span class="line">     node2 :=tmp.Next.Next</span><br><span class="line">     tmp.Next = node2</span><br><span class="line">     node1.Next = node2.Next</span><br><span class="line">     node2.Next = node1</span><br><span class="line">     tmp = node1</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="25-k个一组翻转链表"><a href="#25-k个一组翻转链表" class="headerlink" title="25.k个一组翻转链表"></a>25.k个一组翻转链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">    dummy:=&amp;ListNode&#123;Val:<span class="number">0</span>,Next:head&#125;</span><br><span class="line">    <span class="comment">//被翻转链表的上一个节点</span></span><br><span class="line">    prev_node:=dummy</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//看看接下来的节点是否有k个，无则结束返回头结点的下一个节点</span></span><br><span class="line">        last:=prev_node</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++&#123;</span><br><span class="line">            last=last.Next</span><br><span class="line">            <span class="keyword">if</span>(last==<span class="literal">nil</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> dummy.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有则开始翻转k个节点</span></span><br><span class="line">        <span class="comment">//当前指针cur指向下一个节点</span></span><br><span class="line">        <span class="comment">//prev-&gt;cur-&gt;next-&gt;other翻转cur和next</span></span><br><span class="line">        <span class="comment">//cur.Next指向next的下一个节点</span></span><br><span class="line">        <span class="comment">//prev-&gt;cur-&gt;other</span></span><br><span class="line">        <span class="comment">//next-&gt;other 此时没有节点指向next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//next指向prev的下一个节点</span></span><br><span class="line">        <span class="comment">//prev-&gt;cur-&gt;other</span></span><br><span class="line">        <span class="comment">//next-&gt;cur-&gt;other</span></span><br><span class="line">        <span class="comment">//prev指向next</span></span><br><span class="line">        <span class="comment">//prev-&gt;next-&gt;cur-&gt;other</span></span><br><span class="line">        <span class="comment">//完成next和cur的翻转</span></span><br><span class="line">        <span class="comment">//再将剩余other与prev.Next翻转既next-&gt;cur部分，如果是与cur翻转结果将变成prev-&gt;next-&gt;other-&gt;cur没有实现完全翻转</span></span><br><span class="line">        cur:=prev_node.Next</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++&#123;</span><br><span class="line">            next:=cur.Next</span><br><span class="line">            cur.Next=next.Next</span><br><span class="line">            next.Next=prev_node.Next</span><br><span class="line">            prev_node.Next=next</span><br><span class="line">        &#125;</span><br><span class="line">        prev_node=cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138 随机链表的复制"></a>138 随机链表的复制</h2><p>该链表每个节点有一个下节点和一个随机节点的指针，复制出来的链表节点不指向原链表的节点</p>
<ol>
<li>两次遍历</li>
</ol>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a Node.</span></span><br><span class="line"><span class="comment">* type Node struct &#123;</span></span><br><span class="line"><span class="comment">*     Val int</span></span><br><span class="line"><span class="comment">*     Next *Node</span></span><br><span class="line"><span class="comment">*     Random *Node</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">     mapp := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]*Node)</span><br><span class="line">     cur:=head</span><br><span class="line">     <span class="comment">//对每一个node创建新node</span></span><br><span class="line">     <span class="comment">//map对应key=旧node，value=新node</span></span><br><span class="line">     <span class="keyword">for</span> cur!=<span class="literal">nil</span>&#123;</span><br><span class="line">         mapp[cur]=&amp;Node&#123;Val:cur.Val&#125;</span><br><span class="line">         cur=cur.Next</span><br><span class="line">     &#125;</span><br><span class="line">     cur=head</span><br><span class="line">     <span class="comment">//再次遍历，对复制的节点添加下一个节点和随机节点</span></span><br><span class="line">     <span class="keyword">for</span> cur!=<span class="literal">nil</span>&#123;</span><br><span class="line">         mapp[cur].Next = mapp[cur.Next]</span><br><span class="line">         mapp[cur].Random = mapp[cur.Random]</span><br><span class="line">         cur=cur.Next</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mapp[head]</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>回溯和哈希</li>
</ol>
<p>对当前节点：如果当前节点未被缓存进map中，则复制一个新的节点，值相等，该新节点的next等于复制后的当前节点的next，random同理</p>
<p>如果该节点已被缓存（已复制），则返回该几点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheMap <span class="keyword">map</span>[*Node]*Node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deepCopy</span><span class="params">(node *Node)</span></span>*Node&#123;</span><br><span class="line">    <span class="keyword">if</span> node==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n,has :=cacheMap[node];has&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node&#123;Val:node.Val&#125;</span><br><span class="line">    cacheMap[node]=newNode</span><br><span class="line">    newNode.Next = deepCopy(node.Next)</span><br><span class="line">    newNode.Random = deepCopy(node.Random)</span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    cacheMap = <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> deepCopy(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p>递归：</p>
<ol>
<li><p>递归的终点是head是nil或者只有一个节点</p>
</li>
<li><p>先将链表切开两半（快慢指针切）</p>
</li>
<li><p>分别对前一半很后一半进行排序</p>
</li>
<li><p>从小到大合并排序好的两半</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment">*     Val int</span></span><br><span class="line"><span class="comment">*     Next *ListNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"> <span class="keyword">if</span> head==<span class="literal">nil</span> || head.Next ==<span class="literal">nil</span> &#123;<span class="keyword">return</span> head&#125;</span><br><span class="line"> slow,fast := head,head.Next</span><br><span class="line"> <span class="keyword">for</span> fast!=<span class="literal">nil</span> &amp;&amp; fast.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">     fast,slow=fast.Next.Next,slow.Next</span><br><span class="line"> &#125;</span><br><span class="line"> middle:=slow.Next</span><br><span class="line"> slow.Next = <span class="literal">nil</span></span><br><span class="line"> left,right:=sortList(head),sortList(middle)</span><br><span class="line"> res:=&amp;ListNode&#123;&#125;</span><br><span class="line"> cur:=res</span><br><span class="line"> <span class="keyword">for</span> left!=<span class="literal">nil</span>&amp;&amp;right!=<span class="literal">nil</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(left.Val&lt;right.Val)&#123;</span><br><span class="line">         cur.Next=left</span><br><span class="line">         left=left.Next</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         cur.Next=right</span><br><span class="line">         right=right.Next</span><br><span class="line">     &#125;</span><br><span class="line">     cur=cur.Next</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> left!=<span class="literal">nil</span>&#123;</span><br><span class="line">     cur.Next=left</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> right!=<span class="literal">nil</span>&#123;</span><br><span class="line">     cur.Next=right</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146 LRU缓存"></a>146 LRU缓存</h2><p>设计一个LRU structure</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    cache <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    <span class="comment">//两个dummy头尾，双向链表记录使用顺序</span></span><br><span class="line">    <span class="comment">//当node被get时，如果node存在，则返回，并将node移到链表头，否则返回-1</span></span><br><span class="line">    <span class="comment">//当node被put时，检查是否存在node的key，如果存在，则修改key并移到链表头即可</span></span><br><span class="line">    <span class="comment">//如果不存在，添加新node，并添加到链表头，同时检查当前cache是否已满，如果已经满了，则移除链表尾，并从map中删除该node</span></span><br><span class="line">    <span class="comment">//移到链表头包括删除该node（前后两个node互相指向即可），且在链表头添加该node两个操作</span></span><br><span class="line">    head,tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    key,value <span class="type">int</span></span><br><span class="line">    prev,next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">(key,value <span class="type">int</span>)</span></span> *DLinkedNode&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key:key,</span><br><span class="line">        value:value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    l:=LRUCache&#123;</span><br><span class="line">        cache: <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head:initDLinkedNode(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        tail:initDLinkedNode(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        capacity:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next=l.tail</span><br><span class="line">    l.tail.prev=l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.cache[key];!ok &#123;<span class="keyword">return</span> <span class="number">-1</span>&#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok:=this.cache[key];!ok &#123;</span><br><span class="line">        <span class="comment">//不存在key，则添加kv</span></span><br><span class="line">        node:=initDLinkedNode(key,value)</span><br><span class="line">        this.cache[key]=node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="comment">//当当前cache的size大于cap时，移除尾部node以及cache里对应被移除的kv</span></span><br><span class="line">        <span class="keyword">if</span> this.size&gt;this.capacity&#123;</span><br><span class="line">            removed:=this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache,removed.key)</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//存在key，则修改value</span></span><br><span class="line">        node:=this.cache[key]</span><br><span class="line">        node.value=value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********helper function**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode)&#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next <span class="comment">//插到dummyhead下一个节点</span></span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next=node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode)&#123;</span><br><span class="line">    node.prev.next=node.next</span><br><span class="line">    node.next.prev=node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode)&#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode&#123;</span><br><span class="line">    node:=this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">author: </span><span class="post-copyright-info"><a href="mailto:undefined">Suki Lee</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">link: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/17/2024-05-17-Leetcode%E5%88%B7%E9%A2%98%E8%AF%A6%E8%A7%A3/">http://example.com/2024/05/17/2024-05-17-Leetcode刷题详解/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">copyright: </span><span class="post-copyright-info">Unless otherwise stated, all articles on this site adopt the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> agreement. Please indicate the source when reprinting <a href="http://example.com">Suki Lee</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2024/05/17/2024-05-17-Database%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/"><i class="fas fa-angle-left">&nbsp;</i><span>2024-05-17-Database数据库进阶</span></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="copyright">&copy;2024 By Suki Lee</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>